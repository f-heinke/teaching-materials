```{r}
library("dplyr")
library("cmdstanr")

```


```{r}
d <- read.table("https://f-heinke.github.io/teaching-materials/bsf25/shotgun.df.tab", header = T) %>% 
  filter( gun == "Stevens")
```


# Modell 1

Simulations Code

```{r}
sim_params1 <- function(alpha, beta, sigma, sim_fun){
  sim_fun(alpha, beta, sigma)
}
```



Funktion zum Erzeugen von Prior-Draws

```{r}
pr1.1 <- function(){
  list(
    alpha = rnorm(1, 0, 5),
    beta  = rnorm(1, 2, 1),
    sigma = rexp(1, 0.1)
  )
}


```

Prior Predictive Simulation -- Erzeugt der Prior näherungsweise sinnvolle Flächen?


```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16)
for(i in 1:100){
  
  # draw from prior
  prior_draw <- pr1.1()
  
  # simulate ares from prior, given distances D
  areas_simulated <- sim_params1(
    
    alpha = prior_draw$alpha,
    beta = prior_draw$beta,
    sigma = prior_draw$sigma,
    
    sim_fun = function(alpha, beta, sigma){
      N <- nrow( d )
      areas_prior_sim <- rnorm(N, 
                               beta * d$range_m + alpha, 
                               sigma)
      return( areas_prior_sim )
    }
  )
  
  points( d$range_m, areas_simulated, col = adjustcolor("black", 0.2) )
}
points(d$range_m, d$sqrt.area_cm, col = 4, pch = 16)
```



Model fitting

```{r}
m1 <- cmdstan_model( "shotguns_m1.stan" )
```

```{r}
md <- list(
  N = nrow( d ),
  D = d$range_m,
  A = d$sqrt.area_cm
)
```


```{r}
f1 <- m1$sample( data = md, parallel_chains = 4, refresh = 0 )
```

```{r}
f1
```

```{r}
draws1 <- f1$draws( format = "df" )
```



Posterior Predictive Simulation 1.1 -- Erzeugt die Posterior-Verteilung datenkonsistente Flächen?

```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16, ylim = c(0, 50))
for(i in 1:100){
  
  # draw parameters from posterior
  post_draw <- slice_sample(draws1, n = 1)
  
  areas_simulated <- sim_params1(
    alpha = post_draw$alpha,
    beta  = post_draw$beta,
    sigma = post_draw$sigma,
    
    sim_fun = function(alpha, beta, sigma){
      N <- nrow( d )
      areas_post_sim <- rnorm(N, 
                              beta * d$range_m + alpha, 
                              sigma)
      return( areas_post_sim )
    }
  )
  
  points( d$range_m, areas_simulated, col = adjustcolor("black", 0.01) )
}
points(d$range_m, d$sqrt.area_cm, col = 4, pch = 16)
```


Posterior-Mittelwerte erzeugen die Regressionsgerade

```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16, ylim = c(0, 50))
abline( a = mean( draws1$alpha ),
        b = mean( draws1$beta) )
```


Alternativ: unsicherheitsbehaftete Posterior-Funktionen des Mittelwerts. Erzeugt aus 100 zufälligen Posterior-Draws

```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16, ylim = c(0, 50))

post_draws <-  slice_sample(draws1, n = 100)
for(i in 1:100) abline( a = post_draws$alpha[ i ], 
                        b = post_draws$beta[ i ], 
                        col = adjustcolor(1, 0.1) )

```


Posterior Predictive Simulation 1.2 -- Erzeugt die Posterior-Verteilung datenkonsistente Flächen für *fiktive Distanzen*?


Für diese Distanzen werden wir posterior-prädiktiv Flächen simulieren. 

Je Distanz:
- simuliere Flächen gemäß Posterior-Draws
- bestimme das 90%-Kredibilitätsintervall der simulierten Flächen 


```{r}
range_seq <- seq(0, 20, l = 101)
```

```{r}
# post predictive credible intervals over sequence of ranges

post_area_CI <- sapply(range_seq, function(range){
  
  # number of draws generated by HMC
  Ndraws <- nrow( draws1 )
  
  # simulate Ndraws areas for given range:
  areas_simulated <- sim_params1(
    
    # here we take all draws we obtained!
    alpha = draws1$alpha,
    beta = draws1$beta,
    sigma = draws1$sigma,
    
    # plug all draws into this function
    sim_fun = function(alpha, beta, sigma){
      
      # generate areas randomly, with sigma as error standard deviation
      areas_post_sim <- rnorm(
          Ndraws, 
          beta * range + alpha, 
          sigma)
      
      # 90 % credible interval of posterior predicted areas  
      areas_post_sim_CI90 <- quantile( x = areas_post_sim, c(0.05, 0.95) )
      return( areas_post_sim_CI90 )
    }
  )
})
```


Hier visualisieren wir das Regressionsmodell der Posterior-Mittelwerte. Zudem tragen wir das *90%-Kredibilitätsband*, das wir soeben erzeugt haben, auf:

```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16, ylim = c(0, 50))
abline( a = mean( draws1$alpha ),
        b = mean( draws1$beta))

lines( range_seq, post_area_CI[1, ], lty = 2)
lines( range_seq, post_area_CI[2, ], lty = 2)

```


# Modellansatz 2

Sim code

```{r}
sim_params2 <- function(alpha, beta, rho, tau, sim_fun){
  sim_fun(alpha, beta, rho, tau)
}
```



Priors

```{r}
pr2.1 <- function(){
  list(
    alpha = rnorm(1, 0, 5),
    beta  = rnorm(1, 2, 1),
    rho = rgamma(1, 1.5, 2),
    tau = rexp(1, 10 )
  )
}


```


```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16)
for(i in 1:100){
  
  prior_draw <- pr2.1()
  
  areas_simulated <- sim_params2(
    alpha = prior_draw$alpha,
    beta  = prior_draw$beta,
    rho = prior_draw$rho,
    tau = prior_draw$tau,
    
    sim_fun = function(alpha, beta, rho, tau){
      N <- nrow( d )
      areas_prior_sim <- rnorm(N, 
                               beta * d$range_m + alpha, 
                               rho * d$range_m + tau )
      return( areas_prior_sim )
    }
  )
  
  points( d$range_m, areas_simulated, col = adjustcolor("black", 0.2) )
}
points(d$range_m, d$sqrt.area_cm, col = 4, pch = 16)
```

Fitting

```{r}
m2 <- cmdstan_model( "shotguns_m2.stan" )
```



```{r}
f2 <- m2$sample( data = md, parallel_chains = 4, refresh = 0 )
```

```{r}
f2
```

```{r}
draws2 <- f2$draws( format = "df" )
```



Posterior sim 2

```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16, ylim = c(0, 50))
for(i in 1:100){
  
  # prior_draw <- pr1.1()
  post_draw <- slice_sample(draws2, n = 1)
  
  areas_simulated <- sim_params2(
    alpha = post_draw$alpha,
    beta  = post_draw$beta,
    rho = post_draw$rho,
    tau = post_draw$tau,
    
    sim_fun = function(alpha, beta, rho, tau){
      N <- nrow( d )
      areas_post_sim <- rnorm(N, 
                              beta * d$range_m + alpha, 
                              rho * d$range_m + tau)
      return( areas_post_sim )
    }
  )
  
  points( d$range_m, areas_simulated, col = adjustcolor("black", 0.01) )
}
points(d$range_m, d$sqrt.area_cm, col = 4, pch = 16)
```

```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16, ylim = c(0, 50))
abline( a = mean( draws2$alpha ),
        b = mean( draws2$beta) )
```


```{r}
boxplot( draws1$beta,
         draws2$beta)

boxplot( draws1$alpha,
         draws2$alpha)
```



Posterior sim 2

```{r}
range_seq <- seq(0, 20, l = 101)

# post predictive credible intervals over sequence of ranges

post_area_CI <- sapply(range_seq, function(range){
  Ndraws <- nrow( draws1 )
  
  areas_simulated <- sim_params2(
    alpha = draws2$alpha,
    beta  = draws2$beta,
    rho   = draws2$rho,
    tau   = draws2$tau,
    
    sim_fun = function(alpha, beta, rho, tau){

      areas_post_sim <- rnorm(
          Ndraws, 
          beta * range + alpha, 
          rho  * range + tau)
      
      # 90 % credible interval of posterior predicted areas  
      areas_post_sim_CI90 <- quantile( x = areas_post_sim, c(0.05, 0.95) )
      return( areas_post_sim_CI90 )
    }
  )
})
```

```{r}
plot(d$range_m, d$sqrt.area_cm, col = 4, pch = 16, ylim = c(0, 50))
abline( a = mean( draws2$alpha ),
        b = mean( draws2$beta))

lines( range_seq, post_area_CI[1, ], lty = 2)
lines( range_seq, post_area_CI[2, ], lty = 2)

```


```{r}

```



